<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="pdf:PDFVersion" content="1.7"/>
<meta name="xmp:CreatorTool" content="PDFium"/>
<meta name="pdf:hasXFA" content="false"/>
<meta name="access_permission:modify_annotations" content="true"/>
<meta name="access_permission:can_print_degraded" content="true"/>
<meta name="dcterms:created" content="2021-12-12T11:45:06Z"/>
<meta name="dc:format" content="application/pdf; version=1.7"/>
<meta name="pdf:docinfo:creator_tool" content="PDFium"/>
<meta name="access_permission:fill_in_form" content="true"/>
<meta name="pdf:encrypted" content="false"/>
<meta name="Content-Length" content="6515467"/>
<meta name="pdf:hasMarkedContent" content="false"/>
<meta name="Content-Type" content="application/pdf"/>
<meta name="pdf:producer" content="PDFium"/>
<meta name="access_permission:extract_for_accessibility" content="true"/>
<meta name="access_permission:assemble_document" content="true"/>
<meta name="xmpTPg:NPages" content="4"/>
<meta name="resourceName" content="ddd.pdf"/>
<meta name="pdf:hasXMP" content="false"/>
<meta name="access_permission:extract_content" content="true"/>
<meta name="access_permission:can_print" content="true"/>
<meta name="X-TIKA:Parsed-By" content="org.apache.tika.parser.DefaultParser"/>
<meta name="X-TIKA:Parsed-By" content="org.apache.tika.parser.pdf.PDFParser"/>
<meta name="access_permission:can_modify" content="true"/>
<meta name="pdf:docinfo:producer" content="PDFium"/>
<meta name="pdf:docinfo:created" content="2021-12-12T11:45:06Z"/>
<title></title>
</head>
<body><div class="page"><p/>
<p>[ Team LiB ]
</p>
<p>&nbsp; &nbsp;
</p>
<p>&bull;&nbsp; Table of Contents
</p>
<p>Domain-Driven Design: Tackling Complexity in the Heart of Software
</p>
<p>By Eric&nbsp;Evans
</p>
<p>&nbsp;
</p>
<p>Publisher: Addison Wesley
</p>
<p>Pub Date: August 20, 2003
</p>
<p>ISBN: 0-321-12521-5
</p>
<p>Pages: 560
</p>
<p>The software development community widely acknowledges that domain modeling is central to
software design. Through domain modeling, software developers are able to express rich
functionality and translate that functionality into software implementation that truly serves the
needs of its users. Despite its obvious importance, however, there are few practical resources that
show how to incorporate effective domain modeling into the software development process.
</p>
<p>Domain-Driven Design fills that need. It offers readers a systematic approach to domain-driven
design, presenting an extensive set of design best practices, experience-based techniques, and
fundamental principles that facilitate the development of software projects facing complex
domains. Intertwining design and development practice, Domain-Driven Design incorporates
numerous examples in Java-case studies taken from actual projects that illustrate the application
of domain-driven design to real-world software development.
</p>
<p>Readers will find an overview of domain-driven design that highlights key principles, terms, and
implications. The book presents a core of best practices and standard patterns that provide a
common language for the development team. In addition, it highlights how refactoring in domain
modeling, integrated with the frequent iterations of Agile development, leads to deeper insight into
domains and enhanced communication between domain expert and programmer. Building on this
foundation, the book then addresses domain-driven design for complex systems and larger
organizations.
</p>
<p>Specific topics covered include:
</p>
<p>Isolating the domain
</p>
<p>Entities, value objects, services, and modules
</p>
<p>The lifecycle of a domain object</p>
<p/>
</div>
<div class="page"><p/>
<p>Representing processes as domain objects
</p>
<p>Creating functions free of side effects
</p>
<p>Conceptual contours
</p>
<p>Standalone classes
</p>
<p>Extending specifications
</p>
<p>Applying analysis patterns
</p>
<p>Relating design patterns to the model
</p>
<p>Maintaining model integrity
</p>
<p>Formulating the domain vision statement
</p>
<p>Choosing refactoring targets
</p>
<p>Responsibility layers
</p>
<p>Creating a pluggable component framework
</p>
<p>Bringing together large-scale structures and bounded contexts
</p>
<p>With this book in hand, object-oriented developers, system analysts, and designers will have the
guidance they need to think deeply about domains, create rich and accurate domain models, and
transform these models into high-quality, long-lasting software implementations.
</p>
<p>[ Team LiB ]</p>
<p/>
</div>
<div class="page"><p/>
<p>[ Team LiB ]  
</p>
<p>&nbsp; &nbsp;
</p>
<p>&bull;&nbsp; Table of Contents
</p>
<p>Domain-Driven Design: Tackling Complexity in the Heart of Software
</p>
<p>By Eric&nbsp;Evans
</p>
<p>&nbsp;
</p>
<p>Publisher: Addison Wesley
</p>
<p>Pub Date: August 20, 2003
</p>
<p>ISBN: 0-321-12521-5
</p>
<p>Pages: 560
</p>
<p>&nbsp;&nbsp;&nbsp; Copyright
</p>
<p>&nbsp;&nbsp;&nbsp; Praise for Domain-Driven Design
</p>
<p>&nbsp;&nbsp;&nbsp; Foreword
</p>
<p>&nbsp;&nbsp;&nbsp; Preface
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Contrasting Three Projects
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; The Challenge of Complexity
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Design Versus Development Process
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; The Structure of This Book
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Who Should Read This Book
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; A Domain-Driven Team
</p>
<p>&nbsp;&nbsp;&nbsp; Acknowledgments
</p>
<p>&nbsp;&nbsp;&nbsp; Part I:&nbsp; Putting the Domain Model to Work
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;One.&nbsp; Crunching Knowledge
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Ingredients of Effective Modeling
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Knowledge Crunching
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Continuous Learning
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Knowledge-Rich Design
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Deep Models
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;Two.&nbsp; Communication and the Use of Language
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Ubiquitous Language
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Modeling Out Loud
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; One Team, One Language
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Documents and Diagrams
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Explanatory Models
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;Three.&nbsp; Binding Model and Implementation
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Model-Driven Design
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Modeling Paradigms and Tool Support</p>
<p/>
</div>
<div class="page"><p/>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Letting the Bones Show: Why Models Matter to Users
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Hands-On Modelers
</p>
<p>&nbsp;&nbsp;&nbsp; Part II:&nbsp; The Building Blocks of a Model-Driven Design
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;Four.&nbsp; Isolating the Domain
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Layered Architecture
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; The Domain Layer Is Where the Model Lives
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; The Smart UI "Anti-Pattern"
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Other Kinds of Isolation
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;Five.&nbsp; A Model Expressed in Software
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Associations
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Entities (a.k.a. Reference Objects)
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Value Objects
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Services
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Modules (a.k.a. Packages)
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Modeling Paradigms
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;Six.&nbsp; The Life Cycle of a Domain Object
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Aggregates
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Factories
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Repositories
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Designing Objects for Relational Databases
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;Seven.&nbsp; Using the Language: An Extended Example
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Introducing the Cargo Shipping System
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Isolating the Domain: Introducing the Applications
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Distinguishing ENTITIES and VALUE Objects
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Designing Associations in the Shipping Domain
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; AGGREGATE Boundaries
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Selecting REPOSITORIES
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Walking Through Scenarios
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Object Creation
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Pause for Refactoring: An Alternative Design of the Cargo AGGREGATE
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; MODULES in the Shipping Model
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Introducing a New Feature: Allocation Checking
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; A Final Look
</p>
<p>&nbsp;&nbsp;&nbsp; Part III:&nbsp; Refactoring Toward Deeper Insight
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;Eight.&nbsp; Breakthrough
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Story of a Breakthrough
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Opportunities
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Focus on Basics
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Epilogue: A Cascade of New Insights
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;Nine.&nbsp; Making Implicit Concepts Explicit
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Digging Out Concepts
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; How to Model Less Obvious Kinds of Concepts
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Chapter&nbsp;Ten.&nbsp; Supple Design
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Intention-Revealing Interfaces
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Side -Effect-Free Functions
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Assertions
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Conceptual Contours
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Standalone Classes
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Closure of Operations
</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; Declarative Design</p>
<p/>
</div>
</body></html>